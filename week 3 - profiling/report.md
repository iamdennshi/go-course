# Отчет по заданию 3

## Вводная

Результат бенчмарка до оптимизации (BenchmarkSlow) используя `go test -bench=Slow -benchmem`

- `36 27878217 ns/op 20391728 B/op 182854 allocs/op`

Пояснения к выводу:

- (кол-во итераций)
- (время выполнения одной итерации) ns/op
- (кол-во потребления памяти одной итерации) B/op
- (кол-во аллокаций одной итерации) allocs/op

Нужно чтобы один из параметров (ns/op, B/op, allocs/op) был быстрее эталонного результата (см. ниже).
И нужно чтобы один из параметров был не хуже чем на 20% от эталонного результата. Например <allocs/op в моем решении> < (10422\*1.2)

Эталонный результат

- `500 2782432 ns/op 559910 B/op 10422 allocs/op`

## Шаги оптимизации

### Анализ профилей cpu и mem

#### Создание профилей для cpu и mem

```sh
go test -bench=Slow -benchmem -cpuprofile="cpu.out" -memprofile="mem.out" -memprofilerate=1
```

- `memprofilerate=1` - частота сохранения информации об аллокациях

Получаем информацию по cpu

```sh
go tool pprof hw3.test.exe cpu.out
(pprof) web
(pprof) list Slow
```

Основные затраты по cpu

```
30ms     38:           user := make(map[string]interface{})
960ms    40:           err := json.Unmarshal([]byte(line), &user)
1.41s    66:           if ok, err := regexp.MatchString("Android", browser); ...
1.10s    90:           if ok, err := regexp.MatchString("MSIE", browser); ...
20ms    111:           email := r.ReplaceAllString(user["email"].(string), " [at] ")
```

Получаем информацию по mem

```sh
go tool pprof hw3.test.exe mem.out
(pprof) web
(pprof) list Slow
```

Основные затраты по mem

```
26.44MB     22:   fileContents, err := io.ReadAll(file)
15.54MB     40:   err := json.Unmarshal([]byte(line), &user)
63.87MB     66:   if ok, err := regexp.MatchString("Android", browser); ...
41.40MB     90:   if ok, err := regexp.MatchString("MSIE", browser); ...
```

Чтобы посмотреть в более удобном виде (вебе)

- По памяти `go tool pprof -http=:8080 hw3.test.exe mem.out`
- По процессору `go tool pprof -http=:8080 hw3.test.exe cpu.out`

### Исправления

1. Заменил `regexp.MatchString()` на `strings.Contains()` т.к. на использование `regexp.MatchString()` совокупно тратиться 105.24MB памяти и 2.51s процессорного времени

2. Использовал `bufio.NewScanner()` для чтения по строкам из файла т.к. запись всего содержимого файла в переменную занимает 26.44MB и затем парсинг этой переменной занимает 960ms процессорного времени (Вначале использовал bufio.NewReader() с чтением по строкам, оказалось, что он все буферизирует)

3. Использовал бибилотеку `easyjson` для парсинга json т.к. эта библиотека использует кодогенерацию на основе структуры, в отличии от стандартной функции `json.Unmarshal` которая использует рефлексию

```go
// установит easyjson локально, чтобы потом сгенерировать методы для парсинга
go install github.com/mailru/easyjson/easyjson
// добавит зависимость в модуль
go get github.com/mailru/easyjson/easyjson
```

Создал структуру `User` в этом же файле. Перед структурой указал коментарии для парсера `easyjson:json` чтобы именно для этой структуры были созданы парсеры. В структуре указал требуемые поля которые нужно парсить. Полю Browsers указал тег intern. Это позволит сократить количество памяти. Если строка повторяется, то она не будет заного создаваться, а будет указываться на уже созданную такую же строку

```go
//easyjson:json
type User struct {
	Browsers []string `json:",intern`
	Email    string
	Name     string
}
```

Сгенерировал файл командой `easyjson -snake_case fast.go`. Если не указать `-snake_case`, то не будет парсить исходный json т.к. в нем ключи начинаются со строчной буквы, а искать будет с большой т.к. в структуре поля начиюатся с заглавной буквы. Если указать в структуре поля, которые начинаются со строчных букв, то доступ к ним из другого файла будет не доступен (долго не мог разобраться почему у меня не парсится строка в структуру)

4. Заменил `email := r.ReplaceAllString(user.Email, " [at] ")` на `email := strings.ReplaceAll(user.Email, "@", " [at] ")`. В профиле памяти с типом, в котором показывается количество выделенных объектов (`alloc_objects`) у первого варианта 26 907 объектов, а у второго 6 640 объектов. Тем самым это сокращает количество аллокаций памяти.

5. Сразу аллоцировал память на 1000 элементов

### Результат после оптимизации

Сравнение с эталоном

```
BenchmarkSolution   500   2782432 ns/op   559910 B/op  10422 allocs/op
BenchmarkFast-3     786   1450810 ns/op   392485 B/op   3550 allocs/op
              		+57.2 %  -47.9 %ns/op   -29.9 %B/op  -65.9 %allocs/op
```

### Улучшения по коду

1. Удалил переменную `uniqueBrowsers` т.к. она нигде не используется.
   Уникальные браузеры могут быть получены через len(seenBrowsers)

2. Использовал 1 цикл, а не 2 для обхода браузеров т.к. дополнительный цикл никакой пользы не несет

### Дополнительно

Написал скрипт на питоне (`percent.py`) который принимает на вход две строки с метриками для сравнения и выводит строку показывающую на сколько процентов увеличился или уменьшился соответсвующий параметр
